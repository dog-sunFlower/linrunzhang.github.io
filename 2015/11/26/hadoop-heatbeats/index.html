
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>hadoop heatbeats | FrankLin&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="linrunzhang">
    
    <meta name="description" content="hadoop的心跳过程：
1) master启动的时候，会开一个ipc server在那里。2) slave启动时，会连接master，并每隔3秒钟主动向master发送一个“心跳”，将自己的状态信息告诉master，然后master也是通过这个心跳的返回值，向slave节点传达指令。
2、找到心跳">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="FrankLin&#39;s World" title="FrankLin&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="FrankLin&#39;s World">FrankLin&#39;s World</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:linrunzhang.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/26/hadoop-heatbeats/" title="hadoop heatbeats" itemprop="url">hadoop heatbeats</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://linrunzhang.github.io" title="linrunzhang">linrunzhang</a>
    </p>
  <p class="article-time">
    <time datetime="2015-11-26T02:52:36.000Z" itemprop="datePublished">2015-11-26</time>
    更新日期:<time datetime="2015-11-26T03:04:04.000Z" itemprop="dateModified">2015-11-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
		</div>
		
		<p>hadoop的心跳过程：</p>
<p>1) master启动的时候，会开一个ipc server在那里。<br>2) slave启动时，会连接master，并每隔3秒钟主动向master发送一个“心跳”，将自己的状态信息告诉master，然后master也是通过这个心跳的返回值，向slave节点传达指令。</p>
<p>2、找到心跳的代码</p>
<p>拿namenode和datanode来说，在datanode的offerService方法中，每隔3秒向namenode发送心跳的代码：</p>
<p>[java] view plaincopy<br>/** </p>
<ul>
<li>Main loop for the DataNode.  Runs until shutdown, </li>
<li><p>forever calling remote NameNode functions.<br>*/<br>public void offerService() throws Exception {  </p>
<p>…  </p>
<p>//<br>// Now loop for a long time….<br>//  </p>
<p>while (shouldRun) {<br> try {<br>   long startTime = now();  </p>
<p>   //<br>   // Every so often, send heartbeat or block-report<br>   //  </p>
</li>
</ul>
<p>// 如果到了3秒钟，就向namenode发心跳<br>       if (startTime - lastHeartbeat &gt; heartBeatInterval) {<br>         //<br>         // All heartbeat messages include following info:<br>         // – Datanode name<br>         // – data transfer port<br>         // – Total capacity<br>         // – Bytes remaining<br>         //<br>         lastHeartbeat = startTime;<br>         DatanodeCommand[] cmds = namenode.sendHeartbeat(dnRegistration,<br>                                                      data.getCapacity(),<br>                                                      data.getDfsUsed(),<br>                                                      data.getRemaining(),<br>                                                      xmitsInProgress.get(),<br>                                                      getXceiverCount());  </p>
<p>  // 注意上面这行代码，“发送心跳”竟然就是调用namenode的一个方法？？  </p>
<pre><code>myMetrics.heartbeats.inc(<span class="built_in">now</span>() - startTime)<span class="comment">;  </span>
//<span class="built_in">LOG</span>.info(<span class="string">"Just sent heartbeat, with name "</span> + localName)<span class="comment">;  </span>
</code></pre><p>  // 处理对心跳的返回值（namenode传给datanode的指令）<br>         if (!processCommand(cmds))<br>           continue;<br>       }  </p>
<pre><code><span class="comment">// 这里省略很多代码  </span>
</code></pre><p>…<br>   } // while (shouldRun)<br> } // offerService  </p>
<p>上面这段代码，如果是单机的程序，没什么值得奇怪的。但是，这是hadoop集群！datanode和namenode在2台不同的机器（或2个JVM）上运行！datanode机器竟然直接调用namenode的方法！这是怎么实现的？难道是传说中的RMI吗？？</p>
<p>下面我们主要就来分析这个方法调用的细节。</p>
<p>3、心跳的底层细节一：datanode怎么获得namenode对象的？</p>
<p>首先，DataNode类中，有一个namenode的成员变量：</p>
<p>[java] view plaincopy<br>public class DataNode extends Configured<br>    implements InterDatanodeProtocol, ClientDatanodeProtocol, FSConstants, Runnable {<br>  …<br>  public DatanodeProtocol namenode = null;<br>  …<br>}  </p>
<p>下面是NameNode类的定义：</p>
<p>[java] view plaincopy<br>public class NameNode implements ClientProtocol, DatanodeProtocol,<br>                                 NamenodeProtocol, FSConstants,<br>                                 RefreshAuthorizationPolicyProtocol {<br>  …<br>}  </p>
<p>注意：NameNode实现了DatanodeProtocol接口，DatanodeProtocol接口定义了namenode和datanode之间通信的方法。</p>
<p>那么，DataNode类是怎么获取到NameNode类的引用呢？</p>
<p>在Datanode端，为namenode变量赋值的代码：</p>
<p>[java] view plaincopy<br>// connect to name node<br>this.namenode = (DatanodeProtocol)<br>  RPC.waitForProxy(DatanodeProtocol.class,<br>                   DatanodeProtocol.versionID,<br>                   nameNodeAddr,<br>                   conf);  </p>
<p>在继续去RPC类中追踪：在继续去RPC类中追踪：</p>
<p>[java] view plaincopy<br>VersionedProtocol proxy =<br>        (VersionedProtocol) Proxy.newProxyInstance(<br>            protocol.getClassLoader(), new Class[] { protocol },<br>            new Invoker(addr, ticket, conf, factory));  </p>
<p>现在，明白了！<br>1) 对namenode的赋值，并不是真正的new了一个实现了DatanodeProtocol接口的对象，而是获得了一个动态代理！！<br>2) 上面这段代码中，protocol的类型是DatanodeProtocol.class<br>3) 对namenode的所有调用，都被委托(delegate)给了Invoker<br>现在，明白了！<br>1) 对namenode的赋值，并不是真正的new了一个实现了DatanodeProtocol接口的对象，而是获得了一个动态代理！！<br>2) 上面这段代码中，protocol的类型是DatanodeProtocol.class<br>3) 对namenode的所有调用，都被委托(delegate)给了Invoker<br>4、心跳的底层细节二：看看Invoker类<br>Invoker类是org.apache.hadoop.ipc.RPC类的一个静态内部类：<br>[java] view plaincopy<br>private static class Invoker implements InvocationHandler {  </p>
<p>所有的方法调用又被delegate给client的call方法了！</p>
<p>[java] view plaincopy<br>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>            …  </p>
<pre><code>   <span class="type">ObjectWritable</span> value = (<span class="type">ObjectWritable</span>)  
     client.call(new <span class="type">Invocation</span>(<span class="keyword">method</span>, args), address,   
                 <span class="keyword">method</span>.getDeclaringClass(), ticket);  
     ...  
   <span class="keyword">return</span> value.get();  
}  
</code></pre><p>client是Invoker中的成员变量：</p>
<p>[java] view plaincopy<br>private Client client;<br>所以可以看出：DatanodeProtocol中的每个方法调用，都被包装成一个Invocation对象，再由client.call()调用</p>
<p>5、心跳的底层细节三：Invocation类</p>
<p>Invocation类是org.apache.hadoop.ipc.RPC类的一个静态内部类</p>
<p>没有什么业务逻辑方法，主要作用就是一个VO</p>
<p>6、心跳的底层细节四：client类的call方法</p>
<p>接下来重点看client类的call方法：</p>
<p>[java] view plaincopy<br>public Writable call(Writable param, InetSocketAddress addr,<br>                     Class&lt;?&gt; protocol, UserGroupInformation ticket)<br>                     throws InterruptedException, IOException {  </p>
<p>  Call call = new Call(param);<br>// 将Invocation转化为Call<br>  Connection connection = getConnection(addr, protocol, ticket, call);<br>// 连接远程服务器<br>  connection.sendParam(call);                 // send the parameter<br>// 将“序列化”后的call发给过去<br>  boolean interrupted = false;<br>  synchronized (call) {<br>    while (!call.done) {<br>      try {<br>        call.wait();                           // wait for the result<br>// 等待调用结果<br>      } catch (InterruptedException ie) {<br>        // save the fact that we were interrupted<br>        interrupted = true;<br>      }<br>    }  </p>
<pre><code><span class="keyword">if</span> (interrupted) {  
  <span class="comment">// set the interrupt flag now that we are done waiting  </span>
  Thread.currentThread().interrupt();  
}  

<span class="keyword">if</span> (<span class="keyword">call</span>.error != <span class="keyword">null</span>) {  
  <span class="keyword">if</span> (<span class="keyword">call</span>.error <span class="keyword">instanceof</span> RemoteException) {  
    <span class="keyword">call</span>.error.fillInStackTrace();  
    <span class="keyword">throw</span> <span class="keyword">call</span>.error;  
  } <span class="keyword">else</span> { <span class="comment">// local exception  </span>
    <span class="keyword">throw</span> wrapException(addr, <span class="keyword">call</span>.error);  
  }  
} <span class="keyword">else</span> {  
  <span class="keyword">return</span> <span class="keyword">call</span>.value;  
</code></pre><p>// 返回<br>    }<br>  }<br>}  </p>
<p>7、现在，一目了然了</p>
<p>[java] view plaincopy<br>datanode向namenode发送heartbeat过程是这样的：  </p>
<pre><code><span class="title">a</span>) 在datanode初始化获得namenode的proxy  
<span class="title">b</span>) 在datanode上，调用namenode proxy的heartbeat方法：  
    namenode.sendHeartbeat(dnRegistration,  
                                                   <span class="typedef"><span class="keyword">data</span>.getCapacity<span class="container">()</span>,  </span>
                                                   <span class="typedef"><span class="keyword">data</span>.getDfsUsed<span class="container">()</span>,  </span>
                                                   <span class="typedef"><span class="keyword">data</span>.getRemaining<span class="container">()</span>,  </span>
                                                   xmitsInProgress.get(),  
                                                   getXceiverCount());  
<span class="title">c</span>) 在datanode上的namenode动态代理类将这个调用包装成(或者叫“序列化成”)一个<span class="type">Invocation</span>对象，并调用client.call方法  
<span class="title">d</span>) client call方法将<span class="type">Invocation</span>转化为<span class="type">Call</span>对象  
<span class="title">e</span>) client 将call发送到真正的namenode服务器  
<span class="title">f</span>) namenode接收后，转化成namenode端的<span class="type">Call</span>，并process后，通过<span class="type">Responder</span>发回来！  
<span class="title">g</span>) datanode接收结果，并将结果转化为<span class="type">DatanodeCommand</span>[]  
</code></pre><p>8、再看动态代理</p>
<p>动态代理：让“只有接口，没事对应的实现类”成为可能，因为具体方法的实现可以委托给另一个类！！</p>
<p>在这个例子中，就datanode而言，DatanodeProtocol接口是没有实现类的！</p>
<p>9、观Hadoop HDFS 心跳时间</p>
<p>datenode以固定周期向namenode发送心跳，namenode如果在一段时间内没有收到心跳，就会标记datenode为宕机。 此段时间的计算公式是：</p>
<p>timeout  = 2 <em> heartbeat.recheck.interval + 10 </em> dfs.heartbeat.interval<br>默认 heartbeat.recheck.interval 是5分钟，dfs.heartbeat.interval是3秒，所以DN挂了后，NN要确定DN为DEAR需要10min30s，也就是630S自动标识为dead。</p>
<property><br><name>dfs.heartbeat.interval</name><br><value>3</value><br><description>Determines datanode heartbeat interval in seconds.</description><br></property>

<property><br><name>dfs.heartbeat.recheck.interval</name><br><value>20000</value><br><description>Determines when machines are marked dead 单位：毫秒！！！</description><br></property>

<p>查看NN的日志</p>
<p> 2014-04-02 12:24:33,464 INFO org.apache.hadoop.hdfs.server.blockmanagement.HeartbeatManager: Setting heartbeat recheck interval to 30000 since dfs.namenode.stale.datanode.interval is less than dfs.namenode.heartbeat.recheck-interval<br>预计检测时间是=2<em>20+10</em>3=70，结果发现一台DN down了后，NN检测到的时间还是超过了70秒，最终标记DN为dead的时间是660秒，也就是说这项配置根本就没起作用。接下来我把rechekc的参数设置成100000（也就是100秒），最终发现NN检测到DN挂了确实是用了2<em>100+10</em>3 = 230秒。接下来再来解决第一个疑问， 看看什么是dfs.namenode.stale.datanode.interval，这里引进了一个状态叫做“stale”</p>
<p>DataNodes are marked as stale if it does not send heartbeat message to NameNode within the timeout configured using the configuration parameter “dfs.namenode.stale.datanode.interval” in seconds (default value is 30 seconds). </p>
<p>dfs.namenode.stale.datanode.interval = 30000<br>而且默认情况下这个stale特性是关闭的，还需要把<br>dfs.namenode.check.stale.datanode = true<br>只有把这两项都配置上去，再结合上面的heartbeat才能正常work，否则的话就把dfs.heartbeat.recheck.interval设置成30秒以上吧。因为如果时间太多，那么对于NN来说是要不断更新状态的，负载太高。可以看一段dfs.namenode.stale.datanode.interval的说明</p>
<p>Default time interval for marking a datanode as “stale”, i.e., if the namenode has not received heartbeat msg from a datanode for more than this time interval, the datanode will be marked and treated as “stale” by default. The stale interval cannot be too small since otherwise this may cause too frequent change of stale states. We thus set a minimum stale interval value (the default value is 3 times of heartbeat interval) and guarantee that the stale interval cannot be less than the minimum value. A stale data node is avoided during lease/block recovery. It can be conditionally avoided for reads (see dfs.namenode.avoid.read.stale.datanode) and for writes (see dfs.namenode.avoid.write.stale.datanode).</p>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="http://linrunzhang.github.io/2015/11/26/hadoop-heatbeats/" data-title="hadoop heatbeats | FrankLin&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2015/11/26/hello-world/"  title="Hello World">
 <strong>NEXT:</strong><br/> 
 <span>Hello World
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
  
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  

  

  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://linrunzhang.github.io" target="_blank" title="linrunzhang">linrunzhang</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
